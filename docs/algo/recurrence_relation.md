# Recurrence Relation, 점화식

- [Recurrence Relation, 점화식](#recurrence-relation-점화식)
  - [점화식](#점화식)
  - [점근적 분석 방법](#점근적-분석-방법)
    - [반복 대치](#반복-대치)
    - [추정 후 증명](#추정-후-증명)
    - [마스터 정리](#마스터-정리)
      - [병합 정렬 예](#병합-정렬-예)

## 점화식

- 어떤 함수를 자신과 똑같은 함수를 이용해 나타내는 것
- 자기 호출을 사용하는 함수(재귀함수)의 복잡도 구하는 데 유용

## 점근적 분석 방법

### 반복 대치

```js
function factorial(n)
{
    if(n == 1) return 1
    return n * factorial(n - 1)
}
```

### 추정 후 증명

식의 모양을 보고 점근적 복잡도를 추정한 다음, 그것이 옳음을 귀납적으로 증명하는 방법

> 수학적 귀납법의 다양한 가정과 전개  
>
> - $n = k$ 시 성립, then $n = k + 1$ 시에도 성립
> - $n\leq{k}\lt{n}$인 모든 k에 대해 성립, then n 시에도 성립  
> - $n=k$ 시 성립, then $n=2k$ 시에도 성립  

### 마스터 정리

특정한 모양을 가진 재귀식에서 바로 결과를 알 수 있는 정리

$$
T(n) = a\times{T({n\over{b}}) + f(n)}
$$

- $n$: 풀어야 하는 입력의 크기. 즉, 입력된 데이터의 양
    > 병합 정렬의 경우 `[9, 5, 3, 7, 2, 6, 4, 8, 1]` 정렬해야 한다면 $n=9$
- $a$: 각 단계에서 생성되는 하위 문제의 개수.
    > 병합 정렬의 경우 두 개의 하위 문제로 분할하므로 $a=2$
- $b$: 입력의 크기를 나누는 인수. 하위 문제의 크기를 결정하는 데 사용.
    > 병합 정렬의 경우 두 개의 하위 문제로 분할되므로, 원래 문제 크기의 절반($n\over{2}$)이 되므로 $b=2$
- $n\over{b}$: 각 하위 문제의 입력 크기
- $f(n)$: 나머지 작업

즉, 입력의 크기가 n인 문제를 풀기 위해 입력의 크기가 n/b인 문제를 a개 풀고, 나머지 f(n)의 오버헤드가 필요한 알고리즘들이 해당된다. 아주 많은 알고리즘이 이에 해당되어 마스터 정리는 아주 유용한 방법이다.

앞에서 배운 병합 정렬이 대표적인 예로 a=b=2, f(n)=n인 경우다. 결과는 a, b와 식 f(n)의 모양에 따라 정해진다. $n^{log_{b}{a}}=h(n)$이라 할 때, 이 $h(n)$과 $f(n)$의 상대적인 무게에 따라 전체 복잡도가 결정된다.

> $n^{\log_b{a}}$?  
>
> - `a`: 분할된 문제의 개수  
> - `b`: 입력의 크기를 나누는 인수. 하위 문제의 크기 결정.  
>
> 각 단계에서 문제의 크기는 $\frac{n}{b}$로 축소되고, 총 $a$개의 하위 문제가 생성된다. 각 단계별로 문제의 크기가 어떻게 변하는지를 나타내는 중요한 지표. 재귀 과정에서 **문제 크기의 변화**와 관련된 값이다.  
>
> 재귀 과정 진행하면서 *문제의 크기가 어떻게 변하는지*와 *시간 복잡도* 간의 **상대적 관계**를 파악할 때 마스터 정리에서는 $n^{\log_b{a}}$와 $f(n)$을 비교  
>
> 가령 문제의 크기가 8, 문제의 크기가 둘로 분할될 경우  
> $log_2{8} = 3$이며 크기 8인 문제가 3번 분할된다.
>
> 재귀가 몇 번 발생하는지 재귀적 구조의 깊이와도 관련이 된다

a>1, b>1에 대해 $T(n)=a\times{T}\times{n\over{b}} + f(n)$인 점화식에서, $n^{log_{b}{a}}=h(n)$이라 할 때 $T(n)$의 점근적인 복잡도 정리는:

1. 어떤 양의 상수 $\epsilon$에 대하여, ${h(n)\over{f(n)}}=O({1\over{n^{\epsilon}}})$이면, $T(n)=\Theta(h(n))$이다.
    - ${h(n)\over{f(n)}}$? $h(n)$과 $f(n)$의 성장 속도 비교
    - 양의 상수 $\epsilon\gt0$이므로, $1\over{n^{\epsilon}}$은 계속 작아진다
    - 엡실론이 커질수록 $1\over{n^{\epsilon}}$는 작아진다
    - 이는 $h(n)$이 $f(n)$에 비해 상대적으로 느리게 증가한다는 것을 의미
    - 이 경우 **재귀 호출에 의한 작업이 전체 복잡도를 좌우**하는 주요 요소가 된다
2. 어떤 양의 상수 $\epsilon$에 대하여, ${h(n)\over{f(n)}}=\Omega(n^{\epsilon})$이고, 어떤 상수 c(<1)와 충분히 큰 모든 n에 대해 $a\times{f({n\over{b}})}\le{c\times{f(n)}}$이면 $T(n)=\Theta(f(n))$이다.
3. ${f(n)\over{h(n)}}=\Theta(1)$이면, $T(n)=\Theta(h(n)log{n})$이다.

#### 병합 정렬 예

각 레벨의 작업량과 문제의 크기를 계산하기 위한 재귀 트리

> 조건  
> `[9, 5, 3, 7, 2, 6, 4, 8, 1]`, 분할되는 문제의 개수 $a=2$, 크기를 나누는 인수 $b=2$, $f(n)=n$  
>
> $T(n) = 2\times{T({n\over{2}})} + n$

- 레벨 0:
  - 문제를 $a$개의 부분 문제로 분할. $T({9\over{2}})$ 부분.
    > $T(9) = 2\times{T({9\over{2}})} + 9$
- 레벨 1:
  - $a=2$개로 분할된 부분 문제 해결해야 한다.
  - 레벨 0에서 나눈 각 부분을 다시 절반으로 나눈다.($T({9\over{2^{2}}})$ 부분)
    > $T({9\over{2}}) = 2\times{T({9\over{2^{2}}})} + {9\over{2}}$
- 레벨 2:
  - $a=2$개로 분할된 부분 문제 해결해야 한다.
  - 레벨 1에서 나눈 각 부분을 다시 절반으로 나눈다.($T({9\over{2^{2}}})$ 부분)
    > $T({9\over{2^{2}}}) = 2\times{T({9\over{2^{3}}})} + {9\over{2^{2}}}$
- 레벨 3:
  - 레벨 2에서 나눈 각 부분을 다시 절반으로 나눠야 하나 싶지만, 이때 ${9\over{2^{3}}}\approx{1}$이 되어 문제의 크기가 1이 되므로 분할하지 않는다. 코드에서 `if(n == 1) return;`하는 것과 마찬가지. 다만 병합 과정의 작업량은 발생.
- 병합 단계
  - 병합 단계에서는 원소의 비교 및 병합이 이루어지므로, $f(n)=n$의 작업량이 발생
- 총 처리량
    > $T(9) = 2\times[2\times[2\times{T({9\over{2^{3}}})} + {9\over{2^{2}}}] + {9\over{2}}] + 9$  
    >
    > => $T(9) = 2^{3}\times{T({9\over{2^{3}}})} + 2^{2}\times{9\over{2^{2}}} + 2\times{9\over{2}} + 9$  
    >
    > => $T(9) = 2^{3}\times{T({9\over{2^{3}}})} + 2^{2}\times{9\over{2^{2}}} + 2\times{9\over{2}} + 2^{0}\times{9\over{2^{0}}}$  
- 이를 일반화 하면
    > $T(n) = 2^{k}\times{T({n\over{2^{k}}})} + 2^{k-1}\times{n\over{2^{k-1}}} + ... +  2^{1}\times{n\over{2^{1}}} + 2^{0}\times{n\over{2^{0}}}$
  - 근데 병합 정렬에서 마지막 $T({n\over{2^{k}}})$ 단계에서는 더이상 나눌 수 없는 작업량이 되어 이 값은 어떤 처리량 상수가 된다.
    > $T(1) = c$라는 상수 가정
  - 위 식에서 $T({n\over{2^{k}}})$ 때 점화식이 더이상 호출되지 않으므로, 재귀가 완료되는 시점은 $n={2^{k}}$이며, $k=\log_2(n)$된다.
    > $T(n) = 2^{k}\times{c} + n\times({{2^{k-1}\over{2^{k-1}}} + ... +  {2^{1}\over{2^{1}}} + {2^{0}\over{2^{0}}}})$  
    >
    > => $T(n) = 2^{k}\times{c} + n\times(1 + ... + 1 + 1)$  
    >
    > => $T(n) = 2^{k}\cdot{c} + n\cdot(k)$  
    >
    > => $T(n) = 2^{log_2(n)}\cdot{c} + n\cdot(log_2(n))$  
    >
    > => $T(n) = n \cdot c + n \cdot \log_2(n)$
  - 점근적 복잡도 구하기 위해 모든 $n > n_0$에 대해 $T(n) \le k \cdot n \cdot log_2(n) + c \cdot n$을 만족하는 상수 $k$와 $c$가 존재함을 보여야 한다.
    > $k$와 $c$를 적절히 선택. (예: $k = 2 $, $c = 1$)  
    >
    > $T(n) = n \cdot c + n \cdot \log_2(n) \le k \cdot n \cdot \log_2(n) + c \cdot n$

병합 정렬의 시간 복잡도는 $O(n \log_2 n)$가 된다.
